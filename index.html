<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gensyn Runner: Race for Verification</title>
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #050505;
            --grid-color: #1a1a1a;
            --gensyn-orange: #FF5722; /* Approximate accent */
            --gensyn-white: #F0F0F0;
            --neon-green: #00FF41;
            --error-red: #FF0033;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--gensyn-white);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 400px;
            border: 1px solid var(--grid-color);
            background: linear-gradient(180deg, #000000 0%, #0a0a0a 100%);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* Let clicks pass through to canvas */
            text-align: center;
            text-transform: uppercase;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--neon-green);
            letter-spacing: 4px;
        }

        p {
            font-size: 0.9rem;
            color: #888;
            max-width: 80%;
            line-height: 1.5;
        }

        .stat-box {
            position: absolute;
            top: 20px;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 0 0 5px var(--neon-green);
        }
        
        #score-display { left: 20px; color: var(--neon-green); }
        #status-display { right: 20px; color: var(--gensyn-orange); font-size: 0.8rem;}

        /* Buttons */
        .btn {
            pointer-events: auto;
            background: transparent;
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            padding: 15px 30px;
            font-family: inherit;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .btn:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 20px var(--neon-green);
        }

        /* Mobile Controls hint */
        #mobile-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #444;
            font-size: 0.7rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD -->
        <div id="score-display" class="stat-box">EPOCHS: 0</div>
        <div id="status-display" class="stat-box">NODE STATUS: IDLE</div>

        <!-- Start Screen -->
        <div id="start-screen" class="ui-layer">
            <h1 style="color:white;">GENSYN RUNNER</h1>
            <p>DECENTRALIZED COMPUTE PROTOCOL INITIATED.</p>
            <p>Avoid Centralized Servers (Red) & Latency Spikes.</p>
            <p>Collect Gradients (Green) to Verify.</p>
            <button class="btn" id="start-btn">INITIALIZE NODE</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-layer hidden">
            <h1 style="color:var(--error-red);">VERIFICATION FAILED</h1>
            <p>YOUR STAKE HAS BEEN SLASHED.</p>
            <p id="final-score" style="color:white; margin-top:10px; font-size:1.5rem;">EPOCHS: 0</p>
            <button class="btn" id="restart-btn">REBOOT SYSTEM</button>
        </div>

        <div id="mobile-hint">TAP SCREEN or PRESS SPACE TO JUMP</div>
    </div>

    <script>
        /* --- JAVASCRIPT GAME LOGIC --- */
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreDisplay = document.getElementById('score-display');
        const statusDisplay = document.getElementById('status-display');
        const finalScoreDisplay = document.getElementById('final-score');

        // Game State
        let gameRunning = false;
        let animationId;
        let score = 0;
        let speed = 0;
        let frameCount = 0;
        const GRAVITY = 0.6;
        const BASE_SPEED = 5;

        // Responsive sizing
        let GAME_WIDTH = 800;
        let GAME_HEIGHT = 400;

        function resize() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            GAME_WIDTH = canvas.width;
            GAME_HEIGHT = canvas.height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ASSETS / OBJECTS ---

        // The Player (Solver Node)
        const player = {
            x: 50,
            y: 0,
            width: 30,
            height: 30,
            dy: 0,
            jumpForce: -11,
            grounded: false,
            color: '#00FF41',
            
            draw: function() {
                // Draw glowing cube
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Inner detail (Chip look)
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);
            },

            update: function() {
                // Jump Logic
                if (keys['Space'] || keys['ArrowUp'] || keys['Touch']) {
                    if (this.grounded) {
                        this.dy = this.jumpForce;
                        this.grounded = false;
                        createParticles(this.x + this.width/2, this.y + this.height, 5, '#fff');
                    }
                }

                // Gravity
                this.y += this.dy;
                if (this.y + this.height < GAME_HEIGHT - 50) {
                    this.dy += GRAVITY;
                    this.grounded = false;
                } else {
                    this.dy = 0;
                    this.grounded = true;
                    this.y = GAME_HEIGHT - 50 - this.height;
                }
            }
        };

        // Managers
        let obstacles = [];
        let particles = [];
        let backgroundGridOffset = 0;

        class Obstacle {
            constructor(type) {
                this.w = type === 'server' ? 40 : 20;
                this.h = type === 'server' ? 60 : 20; // Server is tall, spike is small
                this.x = GAME_WIDTH;
                this.y = type === 'server' ? GAME_HEIGHT - 50 - this.h : GAME_HEIGHT - 50 - this.h - 30; // Spikes can float or sit
                if (type === 'spike') this.y = GAME_HEIGHT - 50 - this.h;
                
                this.type = type;
                this.markedForDeletion = false;
            }

            update() {
                this.x -= speed;
                if (this.x + this.w < 0) this.markedForDeletion = true;
            }

            draw() {
                ctx.shadowBlur = 10;
                if (this.type === 'server') {
                    // Centralized Server (Big Block)
                    ctx.shadowColor = '#FF0033';
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    // Server Lights
                    ctx.fillStyle = '#FF0033';
                    ctx.fillRect(this.x + 5, this.y + 5, 5, 5);
                    ctx.fillRect(this.x + 5, this.y + 15, 5, 5);
                } else {
                    // Corruption Spike
                    ctx.shadowColor = '#FF5722';
                    ctx.fillStyle = '#FF5722';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.h);
                    ctx.lineTo(this.x + this.w / 2, this.y);
                    ctx.lineTo(this.x + this.w, this.y + this.h);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 3 + 1;
                this.speedX = Math.random() * 2 - 1;
                this.speedY = Math.random() * 2 - 1;
                this.color = color;
                this.life = 1.0;
            }
            update() {
                this.x -= speed; // Move with world
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function createParticles(x, y, count, color) {
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        // --- INPUT HANDLING ---
        const keys = {};
        
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'Space' && !gameRunning && startScreen.classList.contains('hidden') && !gameOverScreen.classList.contains('hidden')) {
                 // Allow restart with space if game over
                 restartGame();
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            keys['Touch'] = true;
            if(!gameRunning && !gameOverScreen.classList.contains('hidden')) restartGame();
        }, {passive: false});
        
        canvas.addEventListener('touchend', (e) => {
             e.preventDefault();
             keys['Touch'] = false;
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', restartGame);

        // --- GAME LOOP ---

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameRunning = true;
            score = 0;
            speed = BASE_SPEED;
            obstacles = [];
            particles = [];
            player.y = GAME_HEIGHT - 100;
            player.dy = 0;
            statusDisplay.innerText = "NODE STATUS: COMPUTING";
            statusDisplay.style.color = "var(--neon-green)";
            animate();
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            statusDisplay.innerText = "NODE STATUS: OFFLINE";
            statusDisplay.style.color = "var(--error-red)";
            finalScoreDisplay.innerText = "FINAL EPOCHS: " + Math.floor(score);
            gameOverScreen.classList.remove('hidden');
            cancelAnimationFrame(animationId);
        }

        function spawnObstacle() {
            // Difficulty curve: Spawn faster as score increases
            let spawnRate = 120; 
            if (score > 500) spawnRate = 90;
            if (score > 1000) spawnRate = 60;

            if (frameCount % spawnRate === 0) {
                let type = Math.random() < 0.5 ? 'server' : 'spike';
                obstacles.push(new Obstacle(type));
            }
        }

        function drawBackground() {
            // Draw Grid Floor
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            
            // Horizontal lines moving
            let floorY = GAME_HEIGHT - 50;
            ctx.beginPath();
            ctx.moveTo(0, floorY);
            ctx.lineTo(GAME_WIDTH, floorY);
            ctx.stroke();

            // Perspective Grid logic (Simplified for 2D runner)
            backgroundGridOffset -= speed * 0.5;
            if (backgroundGridOffset <= -40) backgroundGridOffset = 0;

            ctx.strokeStyle = '#333';
            for (let i = backgroundGridOffset; i < GAME_WIDTH; i += 40) {
                // Vertical grid lines
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, GAME_HEIGHT);
                ctx.stroke();
            }
        }

        function animate() {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frameCount++;
            score += 0.5; // Distance score
            
            // Speed increase over time
            if (score % 500 === 0) speed += 0.5;

            drawBackground();

            // Player
            player.update();
            player.draw();

            // Obstacles
            spawnObstacle();
            obstacles.forEach((obs, index) => {
                obs.update();
                obs.draw();

                // Collision Detection
                if (
                    player.x < obs.x + obs.w &&
                    player.x + player.width > obs.x &&
                    player.y < obs.y + obs.h &&
                    player.y + player.height > obs.y
                ) {
                    // Collision!
                    createParticles(player.x, player.y, 20, '#FF0033');
                    gameOver();
                }

                if (obs.markedForDeletion) obstacles.splice(index, 1);
            });

            // Particles
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(index, 1);
            });

            // UI Update
            scoreDisplay.innerText = "EPOCHS: " + Math.floor(score);

            animationId = requestAnimationFrame(animate);
        }

        // Initial Draw
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        
    </script>
</body>
</html>